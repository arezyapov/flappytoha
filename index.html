<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="FlappyToha">
<link rel="apple-touch-icon" href="icon-180.png">
<link rel="manifest" href="manifest.json">
<title>FlappyToha</title>
<script>if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');</script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body {
    width: 100%; height: 100%;
    overflow: hidden;
    background: #000;
    font-family: -apple-system, 'SF Pro Display', 'Helvetica Neue', sans-serif;
    -webkit-user-select: none;
    user-select: none;
    cursor: default;
    touch-action: manipulation;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }
  canvas {
    display: block;
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

// ── Responsive sizing ──
const DPR = window.devicePixelRatio || 1;
const GAME_RATIO = 500 / 750; // W/H ratio

function resize() {
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;
  let w, h;
  if (screenW / screenH > GAME_RATIO) {
    h = screenH;
    w = h * GAME_RATIO;
  } else {
    w = screenW;
    h = w / GAME_RATIO;
  }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = 500 * DPR;
  canvas.height = 750 * DPR;
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const W = 500, H = 750;

// ── Colors ──
const COL = {
  bg1: '#1a1a2e',
  bg2: '#16213e',
  bg3: '#0f3460',
  bird: '#ff6b6b',
  birdStroke: '#ee5a5a',
  birdEye: '#fff',
  birdPupil: '#1a1a2e',
  pipe: '#2ecc71',
  pipeEdge: '#27ae60',
  pipeDark: '#1e8449',
  bonus: '#f1c40f',
  bonusGlow: 'rgba(241,196,15,0.3)',
  text: '#fff',
  textShadow: 'rgba(0,0,0,0.5)',
  overlay: 'rgba(0,0,0,0.55)',
  score: '#f39c12',
  ground: '#2c3e50',
  groundLine: '#34495e',
};

// ── Background texture (random dots + stars) ──
const bgStars = [];
for (let i = 0; i < 80; i++) {
  bgStars.push({
    x: Math.random() * W,
    y: Math.random() * H * 0.75,
    r: Math.random() * 1.8 + 0.3,
    a: Math.random() * 0.6 + 0.2,
    twinkleSpeed: Math.random() * 0.03 + 0.01,
    phase: Math.random() * Math.PI * 2,
  });
}

// ── Ground pattern ──
const GROUND_H = 50;

// ── Game state ──
let state = 'start';
let score = 0;
let best = parseInt(localStorage.getItem('flappy_best') || '0');
let frame = 0;
let shakeTimer = 0;
let lives = 3;
const MAX_LIVES = 3;
let invincible = 0;

// ── Bird ──
const bird = {
  x: 80,
  y: H / 2,
  r: 20,
  vy: 0,
  angle: 0,
  flapFrame: 0,
};
const GRAVITY = 0.45;
const FLAP = -7.5;
const MAX_VY = 10;

// ── Pipes ──
let pipes = [];
const PIPE_W = 55;
const GAP = 150;
const BASE_SPEED = 2.5;
const SPEED_STEP = 0.3;
const BASE_INTERVAL = 180;
let pipeSpeed = BASE_SPEED;
let pipeInterval = BASE_INTERVAL;
let pipeTimer = 0;

// ── Bonuses ──
let bonuses = [];
const BONUS_SIZE = 14;

// ── Speech bubble ──
const PHRASES = [
  'Робот-робот-робот...',
  'ААААААХООТНИИК!!!',
  'Рыжий молодец —\nу меня большой конец',
  'Свет мне на центр',
  'Сердцу не прикажешь —\nхую не откажешь',
  'Пацаны, я сегодня\nтолько пиво',
  'Лех, у меня\nперегородка двигается',
];
let bubble = { active: false, text: '', timer: 0, cooldown: 0 };
const BUBBLE_SHOW = 120;
const BUBBLE_MIN_CD = 180;
const BUBBLE_MAX_CD = 420;
let hunterTriggered = false;

function initBubbleCooldown() {
  bubble.cooldown = BUBBLE_MIN_CD + Math.floor(Math.random() * (BUBBLE_MAX_CD - BUBBLE_MIN_CD));
}

// ── Bird texture ──
const birdImg = new Image();
birdImg.src = 'bird.png';
let birdImgLoaded = false;
birdImg.onload = () => { birdImgLoaded = true; };

// ── Hurt face texture ──
const hurtImg = new Image();
hurtImg.src = 'hurt.png';
let hurtImgLoaded = false;
hurtImg.onload = () => { hurtImgLoaded = true; };
let hurtTimer = 0;
const HURT_DURATION = 120;

// ── Bonus textures ──
const bonus1Img = new Image();
bonus1Img.src = 'bonus1.png';
let bonus1ImgLoaded = false;
bonus1Img.onload = () => { bonus1ImgLoaded = true; };

const pipeImg = new Image();
pipeImg.src = 'pipe.png';
let pipeImgLoaded = false;
pipeImg.onload = () => { pipeImgLoaded = true; };

const bonus2Img = new Image();
bonus2Img.src = 'bonus2.png';
let bonus2ImgLoaded = false;
bonus2Img.onload = () => { bonus2ImgLoaded = true; };

const bonus3Img = new Image();
bonus3Img.src = 'bonus3.png';
let bonus3ImgLoaded = false;
bonus3Img.onload = () => { bonus3ImgLoaded = true; };

// ── Heart texture for HUD ──
const heartImg = new Image();
heartImg.src = 'heart.png';
let heartImgLoaded = false;
heartImg.onload = () => { heartImgLoaded = true; };

// ── Life pickups ──
let lifePickups = [];
const LIFE_SPAWN_CHANCE = 0.15;

const lifeImg = new Image();
lifeImg.src = 'life.png';
let lifeImgLoaded = false;
lifeImg.onload = () => { lifeImgLoaded = true; };

// ── Smoke particles (for cigarette pickup) ──
function spawnSmoke() {
  for (let i = 0; i < 20; i++) {
    particles.push({
      x: bird.x + (Math.random() - 0.5) * 10,
      y: bird.y - bird.r - Math.random() * 5,
      vx: (Math.random() - 0.5) * 1.5,
      vy: -Math.random() * 2 - 0.5,
      life: 40 + Math.random() * 30,
      maxLife: 70,
      r: Math.random() * 6 + 3,
      color: 'rgba(200,200,210,',
    });
  }
}

// ── Particles ──
let particles = [];

function updateDifficulty() {
  const level = Math.floor(score / 15);
  pipeSpeed = BASE_SPEED + level * SPEED_STEP;
  pipeInterval = Math.max(110, BASE_INTERVAL - level * 10);
}

function resetGame() {
  bird.y = H / 2;
  bird.vy = 0;
  bird.angle = 0;
  bird.flapFrame = 0;
  pipes = [];
  bonuses = [];
  particles = [];
  pipeSpeed = BASE_SPEED;
  pipeInterval = BASE_INTERVAL;
  pipeTimer = BASE_INTERVAL - 60;
  score = 0;
  frame = 0;
  shakeTimer = 0;
  lives = 3;
  invincible = 0;
  hurtTimer = 0;
  lifePickups = [];
  bubble = { active: false, text: '', timer: 0, cooldown: 0 };
  hunterTriggered = false;
  initBubbleCooldown();
}

function flap() {
  if (state === 'start') {
    state = 'playing';
    resetGame();
    startMusic();
  }
  if (state === 'dead') return;
  bird.vy = FLAP;
  bird.flapFrame = 10;
  const poopColors = [
    'rgba(139,90,43,',
    'rgba(160,105,50,',
    'rgba(120,75,30,',
    'rgba(101,67,33,',
    'rgba(150,95,45,',
  ];
  for (let i = 0; i < 14; i++) {
    particles.push({
      x: bird.x - bird.r + Math.random() * 6 - 3,
      y: bird.y + Math.random() * 14 - 4,
      vx: -Math.random() * 3 - 0.5,
      vy: Math.random() * 3 + 0.5,
      life: 25 + Math.random() * 20,
      maxLife: 45,
      r: Math.random() * 5 + 2,
      color: poopColors[Math.floor(Math.random() * poopColors.length)],
    });
  }
}

function spawnPipe() {
  const minY = 80;
  const maxY = H - GROUND_H - GAP - 80;
  const topH = minY + Math.random() * (maxY - minY);
  pipes.push({ x: W + 10, topH: topH, scored: false });
  if (Math.random() < 0.45) {
    const values = [1, 1, 2, 2, 3];
    const val = values[Math.floor(Math.random() * values.length)];
    bonuses.push({
      x: W + 10 + PIPE_W / 2,
      y: topH + GAP / 2 + (Math.random() - 0.5) * 40,
      collected: false, sparkle: 0, value: val,
    });
  }
  if (lives < MAX_LIVES && Math.random() < LIFE_SPAWN_CHANCE) {
    lifePickups.push({
      x: W + 10 + PIPE_W / 2 + (Math.random() - 0.5) * 60,
      y: topH + GAP / 2 + (Math.random() - 0.5) * 30,
      collected: false, bob: Math.random() * Math.PI * 2,
    });
  }
}

function die() {
  state = 'dead';
  shakeTimer = 15;
  stopMusic();
  if (score > best) {
    best = score;
    localStorage.setItem('flappy_best', String(best));
  }
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 1;
    particles.push({
      x: bird.x, y: bird.y,
      vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
      life: 30 + Math.random() * 20, maxLife: 50,
      r: Math.random() * 4 + 2, color: 'rgba(255,107,107,',
    });
  }
}

function checkCollision() {
  if (bird.y + bird.r > H - GROUND_H || bird.y - bird.r < 0) return 'instant';
  if (invincible <= 0) {
    for (const p of pipes) {
      if (bird.x + bird.r > p.x && bird.x - bird.r < p.x + PIPE_W) {
        if (bird.y - bird.r < p.topH || bird.y + bird.r > p.topH + GAP) return 'pipe';
      }
    }
  }
  return false;
}

function update() {
  frame++;
  if (shakeTimer > 0) shakeTimer--;
  if (hurtTimer > 0 && state === 'dead') hurtTimer--;

  if (state === 'playing') {
    bird.vy += GRAVITY;
    if (bird.vy > MAX_VY) bird.vy = MAX_VY;
    bird.y += bird.vy;
    bird.angle = Math.min(bird.vy * 3, 70);
    if (bird.flapFrame > 0) bird.flapFrame--;

    pipeTimer++;
    if (pipeTimer >= pipeInterval) { spawnPipe(); pipeTimer = 0; }

    for (const p of pipes) {
      p.x -= pipeSpeed;
      if (!p.scored && p.x + PIPE_W < bird.x) { p.scored = true; score++; updateDifficulty(); }
    }
    pipes = pipes.filter(p => p.x > -PIPE_W - 10);

    for (const b of bonuses) {
      b.x -= pipeSpeed; b.sparkle += 0.08;
      if (!b.collected) {
        const dx = bird.x - b.x, dy = bird.y - b.y;
        if (Math.sqrt(dx * dx + dy * dy) < bird.r + BONUS_SIZE) {
          b.collected = true; score += b.value; updateDifficulty();
          const bpc = { 1: 'rgba(52,152,219,', 2: 'rgba(46,204,113,', 3: 'rgba(241,196,15,' };
          const bpColor = bpc[b.value] || bpc[1];
          for (let i = 0; i < 12; i++) {
            const angle = Math.random() * Math.PI * 2, speed = Math.random() * 3 + 1;
            particles.push({ x: b.x, y: b.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 25 + Math.random() * 15, maxLife: 40, r: Math.random() * 3 + 1, color: bpColor });
          }
        }
      }
    }
    bonuses = bonuses.filter(b => b.x > -30 && !b.collected);

    for (const lp of lifePickups) {
      lp.x -= pipeSpeed; lp.bob += 0.06;
      if (!lp.collected) {
        const dx = bird.x - lp.x, dy = bird.y - lp.y;
        if (Math.sqrt(dx * dx + dy * dy) < bird.r + 20) {
          lp.collected = true;
          if (lives < MAX_LIVES) lives++;
          spawnSmoke();
        }
      }
    }
    lifePickups = lifePickups.filter(lp => lp.x > -40 && !lp.collected);

    if (invincible > 0) invincible--;

    // Force hunter phrase at 42s
    if (!hunterTriggered && music.currentTime >= 42 && music.currentTime < 44) {
      hunterTriggered = true;
      bubble.active = true;
      bubble.text = 'ААААААХООТНИИК!!!';
      bubble.timer = BUBBLE_SHOW;
    }
    if (hunterTriggered && music.currentTime < 5) hunterTriggered = false;

    if (bubble.active) {
      bubble.timer--;
      if (bubble.timer <= 0) { bubble.active = false; initBubbleCooldown(); }
    } else {
      bubble.cooldown--;
      if (bubble.cooldown <= 0) {
        bubble.active = true;
        bubble.text = PHRASES[Math.floor(Math.random() * PHRASES.length)];
        bubble.timer = BUBBLE_SHOW;
      }
    }

    if (hurtTimer > 0) hurtTimer--;

    const hit = checkCollision();
    if (hit === 'instant') { lives = 0; hurtTimer = HURT_DURATION; die(); }
    else if (hit === 'pipe') {
      lives--; shakeTimer = 10; invincible = 90; hurtTimer = HURT_DURATION;
      for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2, speed = Math.random() * 3 + 1;
        particles.push({ x: bird.x, y: bird.y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 20 + Math.random() * 10, maxLife: 30, r: Math.random() * 3 + 1, color: 'rgba(255,100,100,' });
      }
      if (lives <= 0) die();
    }
  }

  for (const p of particles) { p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life--; }
  particles = particles.filter(p => p.life > 0);
}

// ── Draw functions ──
function drawBg() {
  const grad = ctx.createLinearGradient(0, 0, 0, H - GROUND_H);
  grad.addColorStop(0, COL.bg1); grad.addColorStop(0.5, COL.bg2); grad.addColorStop(1, COL.bg3);
  ctx.fillStyle = grad; ctx.fillRect(0, 0, W, H - GROUND_H);
  for (const s of bgStars) {
    const twinkle = Math.sin(frame * s.twinkleSpeed + s.phase) * 0.3 + 0.7;
    ctx.globalAlpha = s.a * twinkle; ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2); ctx.fill();
  }
  ctx.globalAlpha = 1;
}

function drawGround() {
  ctx.fillStyle = COL.ground; ctx.fillRect(0, H - GROUND_H, W, GROUND_H);
  ctx.fillStyle = COL.groundLine; ctx.fillRect(0, H - GROUND_H, W, 3);
  const offset = (frame * pipeSpeed) % 20;
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 1;
  for (let x = -offset; x < W; x += 20) {
    ctx.beginPath(); ctx.moveTo(x, H - GROUND_H + 12); ctx.lineTo(x + 10, H - GROUND_H + 12); ctx.stroke();
  }
}

function drawPipe(p) {
  const topH = p.topH, botY = topH + GAP, botH = H - GROUND_H - botY;
  if (pipeImgLoaded) {
    const drawW = PIPE_W + 8;
    ctx.save(); ctx.beginPath(); ctx.rect(p.x - 4, botY, drawW, botH); ctx.clip();
    ctx.drawImage(pipeImg, p.x - 4, botY, drawW, botH); ctx.restore();
    ctx.save(); ctx.beginPath(); ctx.rect(p.x - 4, 0, drawW, topH); ctx.clip();
    ctx.translate(p.x - 4 + drawW / 2, topH / 2); ctx.scale(1, -1);
    ctx.drawImage(pipeImg, -drawW / 2, -topH / 2, drawW, topH); ctx.restore();
  } else {
    const tGrad = ctx.createLinearGradient(p.x, 0, p.x + PIPE_W, 0);
    tGrad.addColorStop(0, COL.pipeDark); tGrad.addColorStop(0.3, COL.pipe);
    tGrad.addColorStop(0.7, COL.pipe); tGrad.addColorStop(1, COL.pipeDark);
    ctx.fillStyle = tGrad; ctx.fillRect(p.x, 0, PIPE_W, topH); ctx.fillRect(p.x, botY, PIPE_W, botH);
  }
}

function drawBird() {
  if (invincible > 0 && Math.floor(frame / 4) % 2 === 0) return;
  const size = bird.r * 2.6;
  ctx.save(); ctx.translate(bird.x, bird.y); ctx.rotate(bird.angle * Math.PI / 180);
  ctx.fillStyle = 'rgba(0,0,0,0.25)'; ctx.beginPath();
  ctx.ellipse(3, 4, bird.r, bird.r * 0.8, 0, 0, Math.PI * 2); ctx.fill();
  const useHurt = hurtTimer > 0 && hurtImgLoaded;
  const faceImg = useHurt ? hurtImg : birdImg;
  const faceLoaded = useHurt ? hurtImgLoaded : birdImgLoaded;
  if (faceLoaded) {
    ctx.beginPath(); ctx.arc(0, 0, size / 2, 0, Math.PI * 2); ctx.clip();
    ctx.drawImage(faceImg, -size / 2, -size / 2, size, size);
  } else {
    ctx.fillStyle = COL.bird; ctx.beginPath(); ctx.arc(0, 0, bird.r, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
}

function drawBubble() {
  if (!bubble.active || state !== 'playing') return;
  let alpha = 1; const fadeFrames = 20;
  if (bubble.timer > BUBBLE_SHOW - fadeFrames) alpha = (BUBBLE_SHOW - bubble.timer) / fadeFrames;
  else if (bubble.timer < fadeFrames) alpha = bubble.timer / fadeFrames;
  ctx.save(); ctx.globalAlpha = alpha;
  const lines = bubble.text.split('\n');
  ctx.font = 'bold 11px -apple-system, sans-serif';
  const lineH = 15, maxW = Math.max(...lines.map(l => ctx.measureText(l).width));
  const padX = 12, padY = 8, bw = maxW + padX * 2, bh = lines.length * lineH + padY * 2, tailH = 10;
  let bx = bird.x - bw / 2, by = bird.y - bird.r - bh - tailH - 8;
  if (bx < 4) bx = 4; if (bx + bw > W - 4) bx = W - 4 - bw;
  if (by < 4) by = bird.y + bird.r + tailH + 4;
  ctx.fillStyle = '#fff'; ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 1.5;
  ctx.beginPath(); ctx.roundRect(bx, by, bw, bh, 10); ctx.fill(); ctx.stroke();
  const tailX = bird.x, tailStartY = by + bh;
  ctx.fillStyle = '#fff';
  ctx.beginPath(); ctx.arc(tailX - 2, tailStartY + 4, 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  ctx.beginPath(); ctx.arc(tailX - 5, tailStartY + 12, 2.5, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
  ctx.fillStyle = '#1a1a2e'; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  for (let i = 0; i < lines.length; i++) ctx.fillText(lines[i], bx + bw / 2, by + padY + i * lineH);
  ctx.restore();
}

function drawBonus(b) {
  const bonusColors = {
    1: { fill: '#3498db', stroke: '#2980b9', glow: 'rgba(52,152,219,0.3)' },
    2: { fill: '#2ecc71', stroke: '#27ae60', glow: 'rgba(46,204,113,0.3)' },
    3: { fill: '#f1c40f', stroke: '#e67e22', glow: 'rgba(241,196,15,0.3)' },
  };
  const col = bonusColors[b.value] || bonusColors[1];
  ctx.save(); ctx.translate(b.x, b.y);
  const pulse = Math.sin(b.sparkle) * 0.15 + 1; ctx.scale(pulse, pulse);

  if (b.value === 1 && bonus1ImgLoaded) {
    const canH = 40, canW = canH * (bonus1Img.width / bonus1Img.height);
    ctx.fillStyle = 'rgba(100,180,255,0.25)'; ctx.beginPath(); ctx.ellipse(0, 0, canW / 2 + 6, canH / 2 + 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.drawImage(bonus1Img, -canW / 2, -canH / 2, canW, canH);
    ctx.fillStyle = '#fff'; ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2.5;
    ctx.font = 'bold 11px -apple-system, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.strokeText('+1', 0, canH / 2 + 10); ctx.fillText('+1', 0, canH / 2 + 10);
  } else if (b.value === 2 && bonus2ImgLoaded) {
    const btlH = 48, btlW = btlH * (bonus2Img.width / bonus2Img.height);
    ctx.fillStyle = 'rgba(46,204,113,0.25)'; ctx.beginPath(); ctx.ellipse(0, 0, btlW / 2 + 6, btlH / 2 + 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.drawImage(bonus2Img, -btlW / 2, -btlH / 2, btlW, btlH);
    ctx.fillStyle = '#fff'; ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2.5;
    ctx.font = 'bold 11px -apple-system, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.strokeText('+2', 0, btlH / 2 + 10); ctx.fillText('+2', 0, btlH / 2 + 10);
  } else if (b.value >= 3 && bonus3ImgLoaded) {
    const btlH = 52, btlW = btlH * (bonus3Img.width / bonus3Img.height);
    ctx.fillStyle = 'rgba(241,196,15,0.25)'; ctx.beginPath(); ctx.ellipse(0, 0, btlW / 2 + 6, btlH / 2 + 6, 0, 0, Math.PI * 2); ctx.fill();
    ctx.drawImage(bonus3Img, -btlW / 2, -btlH / 2, btlW, btlH);
    ctx.fillStyle = '#fff'; ctx.strokeStyle = 'rgba(0,0,0,0.5)'; ctx.lineWidth = 2.5;
    ctx.font = 'bold 11px -apple-system, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.strokeText('+3', 0, btlH / 2 + 10); ctx.fillText('+3', 0, btlH / 2 + 10);
  } else if (b.value >= 3) {
    ctx.fillStyle = col.glow; ctx.beginPath(); ctx.arc(0, 0, BONUS_SIZE + 6, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = col.fill; ctx.strokeStyle = col.stroke; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(0, -BONUS_SIZE); ctx.lineTo(BONUS_SIZE, BONUS_SIZE * 0.8); ctx.lineTo(-BONUS_SIZE, BONUS_SIZE * 0.8); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.font = 'bold 9px -apple-system, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('+3', 0, 2);
  }
  ctx.restore();
}

function drawParticles() {
  for (const p of particles) {
    const alpha = (p.life / p.maxLife) * 0.8;
    ctx.fillStyle = p.color + alpha + ')';
    ctx.beginPath(); ctx.arc(p.x, p.y, p.r * (p.life / p.maxLife), 0, Math.PI * 2); ctx.fill();
  }
}

function drawScore() {
  if (state !== 'playing') return;
  ctx.save();
  ctx.fillStyle = COL.textShadow; ctx.font = 'bold 52px -apple-system, sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'top';
  ctx.fillText(score, W / 2 + 2, 42); ctx.fillStyle = COL.text; ctx.fillText(score, W / 2, 40);
  const heartSize = 24;
  for (let i = 0; i < MAX_LIVES; i++) {
    const hx = 14 + i * 30, hy = 12;
    if (heartImgLoaded) {
      ctx.save();
      if (i >= lives) {
        // Lost heart: draw black silhouette
        ctx.globalAlpha = 0.35;
        ctx.filter = 'brightness(0)';
      }
      ctx.drawImage(heartImg, hx, hy, heartSize, heartSize);
      ctx.restore();
    } else {
      ctx.fillStyle = i < lives ? '#ff4757' : 'rgba(255,255,255,0.15)';
      ctx.fillRect(hx, hy, heartSize, heartSize);
    }
  }
  ctx.restore();
}

function drawLifePickup(lp) {
  ctx.save(); const bobY = Math.sin(lp.bob) * 5; ctx.translate(lp.x, lp.y + bobY);
  ctx.fillStyle = 'rgba(180,80,220,0.2)'; ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI * 2); ctx.fill();
  if (lifeImgLoaded) {
    const h = 38, w = h * (lifeImg.width / lifeImg.height);
    ctx.drawImage(lifeImg, -w / 2, -h / 2, w, h);
  } else {
    if (heartImgLoaded) { ctx.drawImage(heartImg, -12, -12, 24, 24); }
    else { ctx.fillStyle = '#ff4757'; ctx.fillRect(-10, -10, 20, 20); }
  }
  ctx.fillStyle = '#ff4757'; ctx.strokeStyle = 'rgba(0,0,0,0.4)'; ctx.lineWidth = 2;
  ctx.font = 'bold 10px -apple-system, sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.strokeText('+1', 0, 24); ctx.fillText('+1', 0, 24);
  if (heartImgLoaded) { ctx.drawImage(heartImg, 6, 17, 14, 14); }
  ctx.restore();
}

function drawStartScreen() {
  ctx.fillStyle = COL.overlay; ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = COL.text; ctx.font = 'bold 42px -apple-system, sans-serif';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillText('FlappyToha', W / 2, H / 2 - 80);
  const previewY = H / 2 - 10 + Math.sin(frame * 0.05) * 12, previewSize = 56;
  ctx.save(); ctx.translate(W / 2, previewY);
  if (birdImgLoaded) {
    ctx.beginPath(); ctx.arc(0, 0, previewSize / 2, 0, Math.PI * 2); ctx.clip();
    ctx.drawImage(birdImg, -previewSize / 2, -previewSize / 2, previewSize, previewSize);
  } else {
    ctx.fillStyle = COL.bird; ctx.beginPath(); ctx.arc(0, 0, previewSize / 2, 0, Math.PI * 2); ctx.fill();
  }
  ctx.restore();
  ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '16px -apple-system, sans-serif';
  ctx.fillText('Тапните чтобы прыгнуть', W / 2, H / 2 + 60);
  if (best > 0) {
    ctx.fillStyle = COL.score; ctx.font = 'bold 16px -apple-system, sans-serif';
    ctx.fillText('Рекорд: ' + best, W / 2, H / 2 + 95);
  }
  const blink = Math.sin(frame * 0.06) * 0.4 + 0.6;
  ctx.globalAlpha = blink; ctx.fillStyle = '#fff'; ctx.font = '14px -apple-system, sans-serif';
  ctx.fillText('Нажмите чтобы начать', W / 2, H / 2 + 140); ctx.globalAlpha = 1;
}

function drawDeadScreen() {
  ctx.fillStyle = COL.overlay; ctx.fillRect(0, 0, W, H);
  const px = W / 2 - 120, py = H / 2 - 90, pw = 240, ph = 180;
  ctx.fillStyle = 'rgba(30,30,50,0.9)'; ctx.beginPath(); ctx.roundRect(px, py, pw, ph, 16); ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 1; ctx.stroke();
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillStyle = '#ff6b6b'; ctx.font = 'bold 28px -apple-system, sans-serif'; ctx.fillText('Game Over', W / 2, py + 40);
  ctx.fillStyle = COL.text; ctx.font = '18px -apple-system, sans-serif'; ctx.fillText('Очки: ' + score, W / 2, py + 80);
  ctx.fillStyle = COL.score; ctx.font = 'bold 18px -apple-system, sans-serif'; ctx.fillText('Рекорд: ' + best, W / 2, py + 110);
  const blink = Math.sin(frame * 0.06) * 0.3 + 0.7;
  ctx.globalAlpha = blink; ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.font = '14px -apple-system, sans-serif';
  ctx.fillText('Тапните чтобы начать заново', W / 2, py + 152); ctx.globalAlpha = 1;
}

// ── Main loop (locked to 60 FPS) ──
const TARGET_FPS = 60;
const FRAME_DURATION = 1000 / TARGET_FPS;
let lastFrameTime = null;
let accumulator = 0;

function gameLoop(timestamp) {
  if (lastFrameTime === null) {
    lastFrameTime = timestamp;
    requestAnimationFrame(gameLoop);
    return;
  }
  let delta = timestamp - lastFrameTime;
  lastFrameTime = timestamp;
  // Clamp delta to avoid spiral of death after tab switch
  if (delta > 200) delta = FRAME_DURATION;
  accumulator += delta;

  // Run update steps at fixed 60fps rate
  while (accumulator >= FRAME_DURATION) {
    update();
    accumulator -= FRAME_DURATION;
  }

  // Draw once per animation frame
  ctx.save();
  if (shakeTimer > 0) {
    const intensity = shakeTimer * 0.8;
    ctx.translate((Math.random() - 0.5) * intensity, (Math.random() - 0.5) * intensity);
  }
  drawBg();
  for (const p of pipes) drawPipe(p);
  for (const b of bonuses) if (!b.collected) drawBonus(b);
  for (const lp of lifePickups) if (!lp.collected) drawLifePickup(lp);
  drawGround(); drawParticles();
  if (state !== 'start') drawBird();
  drawBubble(); drawScore();
  ctx.restore();
  if (state === 'start') drawStartScreen();
  if (state === 'dead') drawDeadScreen();
  requestAnimationFrame(gameLoop);
}

// ── Input (touch + keyboard + mouse) ──
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  if (state === 'dead') { state = 'start'; resetGame(); }
  else { flap(); }
}, { passive: false });

document.addEventListener('keydown', e => {
  if (e.code === 'Space' || e.key === ' ') {
    e.preventDefault();
    if (state === 'dead') { state = 'start'; resetGame(); }
    else { flap(); }
  }
});

canvas.addEventListener('mousedown', e => {
  e.preventDefault();
  if (state === 'dead') { state = 'start'; resetGame(); }
  else { flap(); }
});

// ── MP3 Music Player ──
const music = new Audio('music.mp3');
music.loop = true;
music.volume = 0.6;

function startMusic() {
  music.currentTime = 0;
  music.play().catch(() => {});
}

function stopMusic() {
  music.pause();
  music.currentTime = 0;
}

// Start
frame = 0;
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
